{"0": {"id": "value:fe802251-d595-4f09-869a-71e67eca18f1", "desc": {"data_type": "dict", "label": "[this value]", "node_type": "value", "data_type_config": {}, "level": 1}, "parentIds": ["module:zdpuAoRTS61Hf3P8nNJFAy1ryxbHQmwjC7K2qpr21X5fRM19t"], "info": {"preview": "dict_data={'7': 0.2352272347011528, '8': 0.22535913106326597, '9': 0.22648812236315757} data_schema={'title': 'dict', 'type': 'object'} python_class=PythonClass(model_id=dict, category=instance.wrapped_python_class, fields=[python_class_name, python_module_name, full_name])"}}, "1": {"id": "module:zdpuAoRTS61Hf3P8nNJFAy1ryxbHQmwjC7K2qpr21X5fRM19t", "desc": {"module_type": "generate.LDA.for.tokens_array", "module_config": {"constants": {}, "defaults": {}}, "label": "generate.LDA.for.tokens_array", "node_type": "operation", "level": 3}, "parentIds": ["value:195805cd-bdda-45d5-abb3-968fc5d3bfd5", "value:d68fb5ef-1c43-4aef-8957-3f7f1f7e6de0", "value:a6454c4e-2605-444d-bff9-b7e8d184091e", "module:zdpuAqYPUdxbgJK3PxJe7iMDjrDhnNDA2P2ZcpbKc7HNpyPwf", "value:5704a550-4f4c-44b2-95f3-bf25364a41ee"], "info": {"type_name": "generate.LDA.for.tokens_array", "documentation": {"description": "Perform Latent Dirichlet Allocation on a tokenized corpus.", "doc": "This module computes models for a range of number of topics provided by the user."}, "authors": {"authors": [{"name": "Markus Binsteiner", "email": "markus@frkl.io"}]}, "context": {"references": {"source_repo": {"url": "https://github.com/DHARPA-Project/kiara_plugin.language_processing", "desc": "The module package git repository."}, "documentation": {"url": "https://DHARPA-Project.github.io/kiara_plugin.language_processing/", "desc": "The url for the module package documentation."}}, "tags": ["language_processing", "LDA", "tokens"], "labels": {"package": "kiara_plugin.language_processing"}}, "python_class": {"python_class_name": "LDAModule", "python_module_name": "kiara_plugin.language_processing.modules.lda", "full_name": "kiara_plugin.language_processing.modules.lda.LDAModule"}, "process_src": "def process(self, inputs: ValueMap, outputs: ValueMap) -> None:\n\n    from gensim import corpora\n\n    logging.getLogger(\"gensim\").setLevel(logging.ERROR)\n    tokens_array: KiaraArray = inputs.get_value_data(\"tokens_array\")\n    tokens = tokens_array.arrow_array.to_pylist()\n\n    words_per_topic = inputs.get_value_data(\"words_per_topic\")\n\n    num_topics_min = inputs.get_value_data(\"num_topics_min\")\n    num_topics_max = inputs.get_value_data(\"num_topics_max\")\n    if num_topics_max is None:\n        num_topics_max = num_topics_min\n\n    compute_coherence = inputs.get_value_data(\"compute_coherence\")\n    id2word = corpora.Dictionary(tokens)\n    corpus = [id2word.doc2bow(text) for text in tokens]\n\n    # model = gensim.models.ldamulticore.LdaMulticore(\n    #     corpus, id2word=id2word, num_topics=num_topics, eval_every=None\n    # )\n\n    models = {}\n    model_tables = {}\n    coherence = {}\n\n    # multi_threaded = False\n    # if not multi_threaded:\n\n    for nt in range(num_topics_min, num_topics_max + 1):\n        model = self.create_model(corpus=corpus, num_topics=nt, id2word=id2word)\n        models[nt] = model\n        topic_print_model = model.print_topics(num_words=words_per_topic)\n        # dbg(topic_print_model)\n        # df = pd.DataFrame(topic_print_model, columns=[\"topic_id\", \"words\"])\n        # TODO: create table directly\n        # result_table = Table.from_pandas(df)\n        model_tables[nt] = topic_print_model\n\n        if compute_coherence:\n            coherence_result = self.compute_coherence(\n                model=model, corpus_model=tokens, id2word=id2word\n            )\n            coherence[nt] = coherence_result\n\n    # else:\n    #     def create_model(num_topics):\n    #         model = self.create_model(corpus=corpus, num_topics=num_topics, id2word=id2word)\n    #         topic_print_model = model.print_topics(num_words=30)\n    #         df = pd.DataFrame(topic_print_model, columns=[\"topic_id\", \"words\"])\n    #         # TODO: create table directly\n    #         result_table = Table.from_pandas(df)\n    #         coherence_result = None\n    #         if compute_coherence:\n    #             coherence_result = self.compute_coherence(model=model, corpus_model=tokens, id2word=id2word)\n    #         return (num_topics, model, result_table, coherence_result)\n    #\n    #     executor = ThreadPoolExecutor()\n    #     results: typing.Any = executor.map(create_model, range(num_topics_min, num_topics_max+1))\n    #     executor.shutdown(wait=True)\n    #     for r in results:\n    #         models[r[0]] = r[1]\n    #         model_tables[r[0]] = r[2]\n    #         if compute_coherence:\n    #             coherence[r[0]] = r[3]\n\n    # df_coherence = pd.DataFrame(coherence.keys(), columns=[\"Number of topics\"])\n    # df_coherence[\"Coherence\"] = coherence.values()\n\n    if compute_coherence:\n        coherence_table = self.assemble_coherence(\n            models_dict=models, words_per_topic=words_per_topic\n        )\n    else:\n        coherence_table = None\n\n    coherence_map = {k: v.item() for k, v in coherence.items()}\n\n    outputs.set_values(\n        topic_models=model_tables,\n        coherence_table=coherence_table,\n        coherence_map=coherence_map,\n    )\n", "config": {"python_class": {"python_class_name": "KiaraModuleConfig", "python_module_name": "kiara.models.module", "full_name": "kiara.models.module.KiaraModuleConfig"}, "config_values": {"constants": {"description": "Value constants for this module.", "type": "object", "value_default": {}, "required": false}, "defaults": {"description": "Value defaults for this module.", "type": "object", "value_default": {}, "required": false}}}}}, "2": {"id": "value:195805cd-bdda-45d5-abb3-968fc5d3bfd5", "desc": {"label": "tokenize_by_word (boolean)", "node_type": "value", "data_type": "boolean", "data_type_config": {}, "level": 8}, "parentIds": [], "info": {"preview": "True"}}, "3": {"id": "value:d68fb5ef-1c43-4aef-8957-3f7f1f7e6de0", "desc": {"label": "num_topics_max (integer)", "node_type": "value", "data_type": "integer", "data_type_config": {}, "level": 4}, "parentIds": [], "info": {"preview": "9"}}, "4": {"id": "value:a6454c4e-2605-444d-bff9-b7e8d184091e", "desc": {"label": "num_topics_min (integer)", "node_type": "value", "data_type": "integer", "data_type_config": {}, "level": 4}, "parentIds": [], "info": {"preview": "7"}}, "5": {"id": "module:zdpuAqYPUdxbgJK3PxJe7iMDjrDhnNDA2P2ZcpbKc7HNpyPwf", "desc": {"module_type": "preprocess.tokens_array", "module_config": {"constants": {}, "defaults": {}}, "label": "preprocess.tokens_array", "node_type": "operation", "level": 5}, "parentIds": ["value:c1c95ddb-31a4-472b-bb89-cd070edbb182", "value:7959e49b-a2b9-4446-84ff-624a1479710a", "module:zdpuAyow1kztfmcrG3aEeKgk4dgDRNh946qzZxX5uN9z3K4w8", "module:zdpuApN9LQPHc9PKSDp3UmCBdFXYhYMEgPmMbRkhQbKAGWCGa"], "info": {"type_name": "preprocess.tokens_array", "documentation": {"description": "Preprocess lists of tokens, incl. lowercasing, remove special characers, etc.", "doc": "Lowercasing: Lowercase the words. This operation is a double-edged sword. It can be effective at yielding potentially better results in the case of relatively small datasets or datatsets with a high percentage of OCR mistakes. For instance, if lowercasing is not performed, the algorithm will treat USA, Usa, usa, UsA, uSA, etc. as distinct tokens, even though they may all refer to the same entity. On the other hand, if the dataset does not contain such OCR mistakes, then it may become difficult to distinguish between homonyms and make interpreting the topics much harder.\n\nRemoving stopwords and words with less than three characters: Remove low information words. These are typically words such as articles, pronouns, prepositions, conjunctions, etc. which are not semantically salient. There are numerous stopword lists available for many, though not all, languages which can be easily adapted to the individual researcher's needs. Removing words with less than three characters may additionally remove many OCR mistakes. Both these operations have the dual advantage of yielding more reliable results while reducing the size of the dataset, thus in turn reducing the required processing power. This step can therefore hardly be considered optional in TM.\n\nNoise removal: Remove elements such as punctuation marks, special characters, numbers, html formatting, etc. This operation is again concerned with removing elements that may not be relevant to the text analysis and in fact interfere with it. Depending on the dataset and research question, this operation can become essential."}, "authors": {"authors": [{"name": "Markus Binsteiner", "email": "markus@frkl.io"}]}, "context": {"references": {"source_repo": {"url": "https://github.com/DHARPA-Project/kiara_plugin.language_processing", "desc": "The module package git repository."}, "documentation": {"url": "https://DHARPA-Project.github.io/kiara_plugin.language_processing/", "desc": "The url for the module package documentation."}}, "tags": ["language_processing", "tokens", "preprocess"], "labels": {"package": "kiara_plugin.language_processing"}}, "python_class": {"python_class_name": "PreprocessModule", "python_module_name": "kiara_plugin.language_processing.modules.tokens", "full_name": "kiara_plugin.language_processing.modules.tokens.PreprocessModule"}, "process_src": "def process(self, inputs: ValueMap, outputs: ValueMap):\n\n    import polars as pl\n    import pyarrow as pa\n\n    tokens_array: KiaraArray = inputs.get_value_data(\"tokens_array\")\n    lowercase: bool = inputs.get_value_data(\"to_lowercase\")\n    remove_alphanumeric: bool = inputs.get_value_data(\"remove_alphanumeric\")\n    remove_non_alpha: bool = inputs.get_value_data(\"remove_non_alpha\")\n    remove_all_numeric: bool = inputs.get_value_data(\"remove_all_numeric\")\n    remove_short_tokens: int = inputs.get_value_data(\"remove_short_tokens\")\n\n    if remove_short_tokens is None:\n        remove_short_tokens = -1\n\n    _remove_stopwords = inputs.get_value_obj(\"remove_stopwords\")\n    if _remove_stopwords.is_set:\n        stopword_list: Optional[Iterable[str]] = _remove_stopwords.data.list_data\n    else:\n        stopword_list = None\n\n    # it's better to have one method every token goes through, then do every test seperately for the token list\n    # because that way each token only needs to be touched once (which is more effective)\n    def check_token(token: str) -> Optional[str]:\n\n        # remove short tokens first, since we can save ourselves all the other checks (which are more expensive)\n        if remove_short_tokens > 0:\n            if len(token) <= remove_short_tokens:\n                return None\n\n        _token: str = token\n        if lowercase:\n            _token = _token.lower()\n\n        if remove_non_alpha:\n            match = _token if _token.isalpha() else None\n            if match is None:\n                return None\n\n        # if remove_non_alpha was set, we don't need to worry about tokens that include numbers, since they are already filtered out\n        if remove_alphanumeric and not remove_non_alpha:\n            match = _token if _token.isalnum() else None\n            if match is None:\n                return None\n\n        # all-number tokens are already filtered out if the remove_non_alpha methods above ran\n        if remove_all_numeric and not remove_non_alpha:\n            match = None if _token.isdigit() else _token\n            if match is None:\n                return None\n\n        if stopword_list and _token and _token.lower() in stopword_list:\n            return None\n\n        return _token\n\n    series = pl.Series(name=\"tokens\", values=tokens_array.arrow_array)\n    result = series.apply(\n        lambda token_list: [\n            x for x in (check_token(token) for token in token_list) if x is not None\n        ]\n    )\n    result_array = result.to_arrow()\n\n    # TODO: remove this cast once the array data type can handle non-chunked arrays\n    chunked = pa.chunked_array(result_array)\n    outputs.set_values(tokens_array=chunked)\n", "config": {"python_class": {"python_class_name": "KiaraModuleConfig", "python_module_name": "kiara.models.module", "full_name": "kiara.models.module.KiaraModuleConfig"}, "config_values": {"constants": {"description": "Value constants for this module.", "type": "object", "value_default": {}, "required": false}, "defaults": {"description": "Value defaults for this module.", "type": "object", "value_default": {}, "required": false}}}}}, "6": {"id": "value:c1c95ddb-31a4-472b-bb89-cd070edbb182", "desc": {"label": "to_lowercase (boolean)", "node_type": "value", "data_type": "boolean", "data_type_config": {}, "level": 6}, "parentIds": [], "info": {"preview": "False"}}, "7": {"id": "value:7959e49b-a2b9-4446-84ff-624a1479710a", "desc": {"label": "remove_short_tokens (integer)", "node_type": "value", "data_type": "integer", "data_type_config": {}, "level": 6}, "parentIds": [], "info": {"preview": "0"}}, "8": {"id": "module:zdpuAyow1kztfmcrG3aEeKgk4dgDRNh946qzZxX5uN9z3K4w8", "desc": {"module_type": "create.stopwords_list", "module_config": {"constants": {}, "defaults": {}}, "label": "create.stopwords_list", "node_type": "operation", "level": 7}, "parentIds": ["value:aa5230e0-f7df-451d-b8de-756e30dda42b", "value:c6b4f1c4-a9c4-4e32-96cc-301e223fc1f9"], "info": {"type_name": "create.stopwords_list", "documentation": {"description": "Create a list of stopwords from one or multiple sources.", "doc": "This will download nltk stopwords if necessary, and merge all input lists into a single, sorted list without duplicates."}, "authors": {"authors": [{"name": "Markus Binsteiner", "email": "markus@frkl.io"}]}, "context": {"references": {"source_repo": {"url": "https://github.com/DHARPA-Project/kiara_plugin.language_processing", "desc": "The module package git repository."}, "documentation": {"url": "https://DHARPA-Project.github.io/kiara_plugin.language_processing/", "desc": "The url for the module package documentation."}}, "tags": ["language_processing"], "labels": {"package": "kiara_plugin.language_processing"}}, "python_class": {"python_class_name": "AssembleStopwordsModule", "python_module_name": "kiara_plugin.language_processing.modules.tokens", "full_name": "kiara_plugin.language_processing.modules.tokens.AssembleStopwordsModule"}, "process_src": "def process(self, inputs: ValueMap, outputs: ValueMap):\n\n    stopwords = set()\n    _languages = inputs.get_value_obj(\"languages\")\n\n    if _languages.is_set:\n        all_stopwords = get_stopwords()\n        languages: ListModel = _languages.data\n\n        for language in languages.list_data:\n\n            if language not in all_stopwords.fileids():\n                raise KiaraProcessingException(\n                    f\"Invalid language: {language}. Available: {', '.join(all_stopwords.fileids())}.\"\n                )\n            stopwords.update(get_stopwords().words(language))\n\n    _stopword_lists = inputs.get_value_obj(\"stopword_lists\")\n    if _stopword_lists.is_set:\n        stopword_lists: ListModel = _stopword_lists.data\n        for stopword_list in stopword_lists.list_data:\n            if isinstance(stopword_list, str):\n                stopwords.add(stopword_list)\n            else:\n                stopwords.update(stopword_list)\n\n    outputs.set_value(\"stopwords_list\", sorted(stopwords))\n", "config": {"python_class": {"python_class_name": "KiaraModuleConfig", "python_module_name": "kiara.models.module", "full_name": "kiara.models.module.KiaraModuleConfig"}, "config_values": {"constants": {"description": "Value constants for this module.", "type": "object", "value_default": {}, "required": false}, "defaults": {"description": "Value defaults for this module.", "type": "object", "value_default": {}, "required": false}}}}}, "9": {"id": "value:aa5230e0-f7df-451d-b8de-756e30dda42b", "desc": {"label": "languages (list)", "node_type": "value", "data_type": "list", "data_type_config": {}, "level": 8}, "parentIds": [], "info": {"preview": "list_data=['italian'] item_schema={'title': 'list', 'type': 'object'} python_class=PythonClass(model_id=list, category=instance.wrapped_python_class, fields=[python_class_name, python_module_name, full_name])"}}, "10": {"id": "value:c6b4f1c4-a9c4-4e32-96cc-301e223fc1f9", "desc": {"label": "remove_tokens (list)", "node_type": "value", "data_type": "list", "data_type_config": {}, "level": 14}, "parentIds": [], "info": {"preview": "list_data=[] item_schema={'title': 'list', 'type': 'object'} python_class=PythonClass(model_id=list, category=instance.wrapped_python_class, fields=[python_class_name, python_module_name, full_name])"}}, "11": {"id": "module:zdpuApN9LQPHc9PKSDp3UmCBdFXYhYMEgPmMbRkhQbKAGWCGa", "desc": {"module_type": "tokenize.texts_array", "module_config": {"constants": {}, "defaults": {}}, "label": "tokenize.texts_array", "node_type": "operation", "level": 7}, "parentIds": ["module:zdpuB1emJxNaL5cYnQ8zEvRaq2azadRPeoQaSqR4eXKE7Up4h", "value:195805cd-bdda-45d5-abb3-968fc5d3bfd5"], "info": {"type_name": "tokenize.texts_array", "documentation": {"description": "Split sentences into words or words into characters.", "doc": "In other words, this operation establishes the word boundaries (i.e., tokens) a very helpful way of finding patterns. It is also the typical step prior to stemming and lemmatization"}, "authors": {"authors": [{"name": "Markus Binsteiner", "email": "markus@frkl.io"}]}, "context": {"references": {"source_repo": {"url": "https://github.com/DHARPA-Project/kiara_plugin.language_processing", "desc": "The module package git repository."}, "documentation": {"url": "https://DHARPA-Project.github.io/kiara_plugin.language_processing/", "desc": "The url for the module package documentation."}}, "tags": ["language_processing", "tokenize", "tokens"], "labels": {"package": "kiara_plugin.language_processing"}}, "python_class": {"python_class_name": "TokenizeTextArrayeModule", "python_module_name": "kiara_plugin.language_processing.modules.tokens", "full_name": "kiara_plugin.language_processing.modules.tokens.TokenizeTextArrayeModule"}, "process_src": "def process(self, inputs: ValueMap, outputs: ValueMap):\n\n    pass\n\n    import nltk\n    import polars as pl\n    import pyarrow as pa\n\n    array: KiaraArray = inputs.get_value_data(\"texts_array\")\n    # tokenize_by_word: bool = inputs.get_value_data(\"tokenize_by_word\")\n\n    column: pa.ChunkedArray = array.arrow_array\n\n    # warnings.filterwarnings(\"ignore\", category=np.VisibleDeprecationWarning)\n\n    def word_tokenize(word):\n        result = nltk.word_tokenize(word)\n        return result\n\n    series = pl.Series(name=\"tokens\", values=column)\n    result = series.apply(word_tokenize)\n\n    result_array = result.to_arrow()\n\n    # TODO: remove this cast once the array data type can handle non-chunked arrays\n    chunked = pa.chunked_array(result_array)\n    outputs.set_values(tokens_array=chunked)\n", "config": {"python_class": {"python_class_name": "KiaraModuleConfig", "python_module_name": "kiara.models.module", "full_name": "kiara.models.module.KiaraModuleConfig"}, "config_values": {"constants": {"description": "Value constants for this module.", "type": "object", "value_default": {}, "required": false}, "defaults": {"description": "Value defaults for this module.", "type": "object", "value_default": {}, "required": false}}}}}, "12": {"id": "module:zdpuB1emJxNaL5cYnQ8zEvRaq2azadRPeoQaSqR4eXKE7Up4h", "desc": {"module_type": "table.cut_column", "module_config": {"constants": {"column_name": "content"}, "defaults": {}}, "label": "table.cut_column", "node_type": "operation", "level": 9}, "parentIds": ["value:61f3241e-f423-4052-93b2-d50887f6c76b", "module:zdpuAzybdPqAwszJEtqjGgiafHHk2y6bVLerT1TfUFkhk94xV"], "info": {"type_name": "table.cut_column", "documentation": {"description": "Cut off one column from a table, returning an array.", "doc": null}, "authors": {"authors": [{"name": "Markus Binsteiner", "email": "markus@frkl.io"}]}, "context": {"references": {"source_repo": {"url": "https://github.com/DHARPA-Project/kiara_plugin.tabular", "desc": "The module package git repository."}, "documentation": {"url": "https://DHARPA-Project.github.io/kiara_plugin.tabular/", "desc": "The url for the module package documentation."}}, "tags": ["tabular"], "labels": {"package": "kiara_plugin.tabular"}}, "python_class": {"python_class_name": "CutColumnModule", "python_module_name": "kiara_plugin.tabular.modules.table", "full_name": "kiara_plugin.tabular.modules.table.CutColumnModule"}, "process_src": "def process(self, inputs: ValueMap, outputs: ValueMap) -> None:\n\n    import pyarrow as pa\n\n    column_name: str = inputs.get_value_data(\"column_name\")\n\n    table_value: Value = inputs.get_value_obj(\"table\")\n    table_metadata: KiaraTableMetadata = table_value.get_property_data(\n        \"metadata.table\"\n    )\n\n    available = table_metadata.table.column_names\n\n    if column_name not in available:\n        raise KiaraProcessingException(\n            f\"Invalid column name '{column_name}'. Available column names: {', '.join(available)}\"\n        )\n\n    table: pa.Table = table_value.data.arrow_table\n    column = table.column(column_name)\n\n    outputs.set_value(\"array\", column)\n", "config": {"python_class": {"python_class_name": "KiaraModuleConfig", "python_module_name": "kiara.models.module", "full_name": "kiara.models.module.KiaraModuleConfig"}, "config_values": {"constants": {"description": "Value constants for this module.", "type": "object", "value_default": {}, "required": false}, "defaults": {"description": "Value defaults for this module.", "type": "object", "value_default": {}, "required": false}}}}}, "13": {"id": "value:61f3241e-f423-4052-93b2-d50887f6c76b", "desc": {"label": "column_name (string)", "node_type": "value", "data_type": "string", "data_type_config": {}, "level": 10}, "parentIds": [], "info": {"preview": "content"}}, "14": {"id": "module:zdpuAzybdPqAwszJEtqjGgiafHHk2y6bVLerT1TfUFkhk94xV", "desc": {"module_type": "table.merge", "module_config": {"constants": {}, "defaults": {}, "inputs_schema": {"source_table": {"type": "table", "type_config": {}, "default": "__not_set__", "optional": false, "is_constant": false, "doc": {"description": "The original table.", "doc": null}}, "date_array": {"type": "array", "type_config": {}, "default": "__not_set__", "optional": false, "is_constant": false, "doc": {"description": "The array containing the parsed date items.", "doc": null}}}, "column_map": {"date": "date_array", "content": "source_table.content", "file_name": "source_table.file_name"}}, "label": "table.merge", "node_type": "operation", "level": 11}, "parentIds": ["module:zdpuAsncFffKfH2J6qok1LLfBWGF3BTHXHVyYK4vV86tujCP4", "module:zdpuAkfC7c35pp8SAfCx7Xmk1G1RQMvEymq4mvjDk47e1H9XN"], "info": {"type_name": "table.merge", "documentation": {"description": "Create a table from other tables and/or arrays.", "doc": "This module needs configuration to be set (for now). It's currently not possible to merge an arbitrary\nnumber of tables/arrays, all tables to be merged must be specified in the module configuration.\n\nColumn names of the resulting table can be controlled by the 'column_map' configuration, which takes the\ndesired column name as key, and a field-name in the following format as value:\n- '[inputs_schema key]' for inputs of type 'array'\n- '[inputs_schema_key].orig_column_name' for inputs of type 'table'"}, "authors": {"authors": [{"name": "Markus Binsteiner", "email": "markus@frkl.io"}]}, "context": {"references": {"source_repo": {"url": "https://github.com/DHARPA-Project/kiara_plugin.tabular", "desc": "The module package git repository."}, "documentation": {"url": "https://DHARPA-Project.github.io/kiara_plugin.tabular/", "desc": "The url for the module package documentation."}}, "tags": ["tabular"], "labels": {"package": "kiara_plugin.tabular"}}, "python_class": {"python_class_name": "MergeTableModule", "python_module_name": "kiara_plugin.tabular.modules.table", "full_name": "kiara_plugin.tabular.modules.table.MergeTableModule"}, "process_src": "def process(self, inputs: ValueMap, outputs: ValueMap, job_log: JobLog) -> None:\n\n    import pyarrow as pa\n\n    inputs_schema: Dict[str, Any] = self.get_config_value(\"inputs_schema\")\n    column_map: Dict[str, str] = self.get_config_value(\"column_map\")\n\n    sources = {}\n    for field_name in inputs_schema.keys():\n        sources[field_name] = inputs.get_value_data(field_name)\n\n    len_dict = {}\n    arrays = {}\n\n    column_map_final = dict(column_map)\n\n    for source_key, table_or_array in sources.items():\n\n        if isinstance(table_or_array, KiaraTable):\n            rows = table_or_array.num_rows\n            for name in table_or_array.column_names:\n                array_name = f\"{source_key}.{name}\"\n                if column_map and array_name not in column_map.values():\n                    job_log.add_log(\n                        f\"Ignoring column '{name}' of input table '{source_key}': not listed in column_map.\"\n                    )\n                    continue\n\n                column = table_or_array.arrow_table.column(name)\n                arrays[array_name] = column\n                if not column_map:\n                    if name in column_map_final:\n                        raise Exception(\n                            f\"Can't merge table, duplicate column name: {name}.\"\n                        )\n                    column_map_final[name] = array_name\n\n        elif isinstance(table_or_array, KiaraArray):\n\n            if column_map and source_key not in column_map.values():\n                job_log.add_log(\n                    f\"Ignoring array '{source_key}': not listed in column_map.\"\n                )\n                continue\n\n            rows = len(table_or_array)\n            arrays[source_key] = table_or_array.arrow_array\n\n            if not column_map:\n                if source_key in column_map_final.keys():\n                    raise Exception(\n                        f\"Can't merge table, duplicate column name: {source_key}.\"\n                    )\n                column_map_final[source_key] = source_key\n\n        else:\n            raise KiaraProcessingException(\n                f\"Can't merge table: invalid type '{type(table_or_array)}' for source '{source_key}'.\"\n            )\n\n        len_dict[source_key] = rows\n\n    all_rows = None\n    for source_key, rows in len_dict.items():\n        if all_rows is None:\n            all_rows = rows\n        else:\n            if all_rows != rows:\n                all_rows = None\n                break\n\n    if all_rows is None:\n        len_str = \"\"\n        for name, rows in len_dict.items():\n            len_str = f\" {name} ({rows})\"\n\n        raise KiaraProcessingException(\n            f\"Can't merge table, sources have different lengths: {len_str}\"\n        )\n\n    column_names = []\n    columns = []\n    for column_name, ref in column_map_final.items():\n        column_names.append(column_name)\n        column = arrays[ref]\n        columns.append(column)\n\n    table = pa.Table.from_arrays(arrays=columns, names=column_names)\n\n    outputs.set_value(\"table\", table)\n", "config": {"python_class": {"python_class_name": "MergeTableConfig", "python_module_name": "kiara_plugin.tabular.modules.table", "full_name": "kiara_plugin.tabular.modules.table.MergeTableConfig"}, "config_values": {"constants": {"description": "Value constants for this module.", "type": "object", "value_default": {}, "required": false}, "defaults": {"description": "Value defaults for this module.", "type": "object", "value_default": {}, "required": false}, "inputs_schema": {"description": "A dict describing the inputs for this merge process.", "type": "object", "value_default": null, "required": true}, "column_map": {"description": "A map describing", "type": "object", "value_default": {}, "required": false}}}}}, "15": {"id": "module:zdpuAsncFffKfH2J6qok1LLfBWGF3BTHXHVyYK4vV86tujCP4", "desc": {"module_type": "parse.date_array", "module_config": {"constants": {}, "defaults": {}, "add_inputs": true, "input_fields": [], "force_non_null": true, "min_index": null, "max_index": null, "remove_tokens": []}, "label": "parse.date_array", "node_type": "operation", "level": 13}, "parentIds": ["module:zdpuB19zscMvy4C9ETug9tGkHsTZ3a3N9FHY8htZS1UaPCX3c", "value:195805cd-bdda-45d5-abb3-968fc5d3bfd5", "value:9bf6c998-9d8b-4571-ac92-a7e3d8d87892", "value:ebfb1534-cef9-400c-9fdb-59c5d2f6302f", "value:c6b4f1c4-a9c4-4e32-96cc-301e223fc1f9"], "info": {"type_name": "parse.date_array", "documentation": {"description": "Create an array of date objects from an array of strings.", "doc": "This module is very simplistic at the moment, more functionality and options will be added in the future.\n\nAt its core, this module uses the standard parser from the\n[dateutil](https://github.com/dateutil/dateutil) package to parse strings into dates. As this parser can't handle\n complex strings, the input strings can be pre-processed in the following ways:\n\n- 'cut' non-relevant parts of the string (using 'min_index' & 'max_index' input/config options)\n- remove matching tokens from the string, and replace them with a single whitespace (using the 'remove_tokens' option)\n\nBy default, if an input string can't be parsed this module will raise an exception. This can be prevented by\nsetting this modules 'force_non_null' config option or input to 'False', in which case un-parsable strings\nwill appear as 'NULL' value in the resulting array."}, "authors": {"authors": [{"name": "Markus Binsteiner", "email": "markus@frkl.io"}]}, "context": {"references": {"source_repo": {"url": "https://github.com/DHARPA-Project/kiara_plugin.tabular", "desc": "The module package git repository."}, "documentation": {"url": "https://DHARPA-Project.github.io/kiara_plugin.tabular/", "desc": "The url for the module package documentation."}}, "tags": ["tabular"], "labels": {"package": "kiara_plugin.tabular"}}, "python_class": {"python_class_name": "ExtractDateModule", "python_module_name": "kiara_plugin.tabular.modules.array", "full_name": "kiara_plugin.tabular.modules.array.ExtractDateModule"}, "process_src": "def process(self, inputs: ValueMap, outputs: ValueMap, job_log: JobLog):\n\n    import polars as pl\n    import pyarrow as pa\n    from dateutil import parser\n\n    force_non_null: bool = self.get_data_for_field(\n        field_name=\"force_non_null\", inputs=inputs\n    )\n    min_pos: Union[None, int] = self.get_data_for_field(\n        field_name=\"min_index\", inputs=inputs\n    )\n    if min_pos is None:\n        min_pos = 0\n    max_pos: Union[None, int] = self.get_data_for_field(\n        field_name=\"max_index\", inputs=inputs\n    )\n    remove_tokens: Iterable[str] = self.get_data_for_field(\n        field_name=\"remove_tokens\", inputs=inputs\n    )\n\n    def parse_date(_text: str):\n\n        text = _text\n        if min_pos:\n            try:\n                text = text[min_pos:]  # type: ignore\n            except Exception:\n                return None\n        if max_pos:\n            try:\n                text = text[0 : max_pos - min_pos]  # type: ignore  # noqa\n            except Exception:\n                pass\n\n        if remove_tokens:\n            for t in remove_tokens:\n                text = text.replace(t, \" \")\n\n        try:\n            d_obj = parser.parse(text, fuzzy=True)\n        except Exception as e:\n            if force_non_null:\n                raise KiaraProcessingException(e)\n            return None\n\n        if d_obj is None:\n            if force_non_null:\n                raise KiaraProcessingException(\n                    f\"Can't parse date from string: {text}\"\n                )\n            return None\n\n        return d_obj\n\n    value = inputs.get_value_obj(\"array\")\n    array: KiaraArray = value.data\n\n    series = pl.Series(name=\"tokens\", values=array.arrow_array)\n    job_log.add_log(f\"start parsing date for {len(array)} items\")\n    result = series.apply(parse_date)\n    job_log.add_log(f\"finished parsing date for {len(array)} items\")\n    result_array = result.to_arrow()\n\n    # TODO: remove this cast once the array data type can handle non-chunked arrays\n    chunked = pa.chunked_array(result_array)\n    outputs.set_values(date_array=chunked)\n", "config": {"python_class": {"python_class_name": "ExtractDateConfig", "python_module_name": "kiara_plugin.tabular.modules.array", "full_name": "kiara_plugin.tabular.modules.array.ExtractDateConfig"}, "config_values": {"constants": {"description": "Value constants for this module.", "type": "object", "value_default": {}, "required": false}, "defaults": {"description": "Value defaults for this module.", "type": "object", "value_default": {}, "required": false}, "add_inputs": {"description": "If set to 'True', parse options will be available as inputs.", "type": "boolean", "value_default": true, "required": false}, "input_fields": {"description": "If not empty, only add the fields specified in here to the module inputs schema.", "type": "array", "value_default": [], "required": false}, "force_non_null": {"description": "If set to 'True', raise an error if any of the strings in the array can't be parsed.", "type": "boolean", "value_default": true, "required": false}, "min_index": {"description": "The minimum index from where to start parsing the string(s).", "type": "integer", "value_default": null, "required": false}, "max_index": {"description": "The maximum index until whic to parse the string(s).", "type": "integer", "value_default": null, "required": false}, "remove_tokens": {"description": "A list of tokens/characters to replace with a single white-space before parsing the input.", "type": "array", "value_default": [], "required": false}}}}}, "16": {"id": "module:zdpuB19zscMvy4C9ETug9tGkHsTZ3a3N9FHY8htZS1UaPCX3c", "desc": {"module_type": "table.cut_column", "module_config": {"constants": {}, "defaults": {}}, "label": "table.cut_column", "node_type": "operation", "level": 15}, "parentIds": ["value:0b8ee78f-921f-4479-b2d1-1e760f826875", "module:zdpuAkfC7c35pp8SAfCx7Xmk1G1RQMvEymq4mvjDk47e1H9XN"], "info": {"type_name": "table.cut_column", "documentation": {"description": "Cut off one column from a table, returning an array.", "doc": null}, "authors": {"authors": [{"name": "Markus Binsteiner", "email": "markus@frkl.io"}]}, "context": {"references": {"source_repo": {"url": "https://github.com/DHARPA-Project/kiara_plugin.tabular", "desc": "The module package git repository."}, "documentation": {"url": "https://DHARPA-Project.github.io/kiara_plugin.tabular/", "desc": "The url for the module package documentation."}}, "tags": ["tabular"], "labels": {"package": "kiara_plugin.tabular"}}, "python_class": {"python_class_name": "CutColumnModule", "python_module_name": "kiara_plugin.tabular.modules.table", "full_name": "kiara_plugin.tabular.modules.table.CutColumnModule"}, "process_src": "def process(self, inputs: ValueMap, outputs: ValueMap) -> None:\n\n    import pyarrow as pa\n\n    column_name: str = inputs.get_value_data(\"column_name\")\n\n    table_value: Value = inputs.get_value_obj(\"table\")\n    table_metadata: KiaraTableMetadata = table_value.get_property_data(\n        \"metadata.table\"\n    )\n\n    available = table_metadata.table.column_names\n\n    if column_name not in available:\n        raise KiaraProcessingException(\n            f\"Invalid column name '{column_name}'. Available column names: {', '.join(available)}\"\n        )\n\n    table: pa.Table = table_value.data.arrow_table\n    column = table.column(column_name)\n\n    outputs.set_value(\"array\", column)\n", "config": {"python_class": {"python_class_name": "KiaraModuleConfig", "python_module_name": "kiara.models.module", "full_name": "kiara.models.module.KiaraModuleConfig"}, "config_values": {"constants": {"description": "Value constants for this module.", "type": "object", "value_default": {}, "required": false}, "defaults": {"description": "Value defaults for this module.", "type": "object", "value_default": {}, "required": false}}}}}, "17": {"id": "value:0b8ee78f-921f-4479-b2d1-1e760f826875", "desc": {"label": "column_name (string)", "node_type": "value", "data_type": "string", "data_type_config": {}, "level": 16}, "parentIds": [], "info": {"preview": "file_name"}}, "18": {"id": "module:zdpuAkfC7c35pp8SAfCx7Xmk1G1RQMvEymq4mvjDk47e1H9XN", "desc": {"module_type": "create.table", "module_config": {"constants": {}, "defaults": {}, "source_type": "text_file_bundle", "target_type": "table", "ignore_errors": false}, "label": "create.table", "node_type": "operation", "level": 13}, "parentIds": ["module:zdpuAvtJAAff57xASJxvSmQ6w7SRS9W4wPQfUVftGcZAjtQdD"], "info": {"type_name": "create.table", "documentation": {"description": "-- n/a --", "doc": null}, "authors": {"authors": [{"name": "Markus Binsteiner", "email": "markus@frkl.io"}]}, "context": {"references": {"source_repo": {"url": "https://github.com/DHARPA-Project/kiara_plugin.tabular", "desc": "The module package git repository."}, "documentation": {"url": "https://DHARPA-Project.github.io/kiara_plugin.tabular/", "desc": "The url for the module package documentation."}}, "tags": ["tabular"], "labels": {"package": "kiara_plugin.tabular"}}, "python_class": {"python_class_name": "CreateTableModule", "python_module_name": "kiara_plugin.tabular.modules.table", "full_name": "kiara_plugin.tabular.modules.table.CreateTableModule"}, "process_src": "def process(self, inputs: ValueMap, outputs: ValueMap) -> None:\n\n    source_type = self.get_config_value(\"source_type\")\n    target_type = self.get_config_value(\"target_type\")\n\n    func_name = f\"create__{target_type}__from__{source_type}\"\n    func = getattr(self, func_name)\n\n    source_value = inputs.get_value_obj(source_type)\n\n    signature = inspect.signature(func)\n    if \"optional\" in signature.parameters:\n        optional: Dict[str, Value] = {}\n        op_schemas = {}\n        for field, schema in self.inputs_schema.items():\n            if field == source_type:\n                continue\n            optional[field] = inputs.get_value_obj(field)\n            op_schemas[field] = schema\n        result = func(\n            source_value=source_value,\n            optional=ValueMapReadOnly(\n                value_items=optional, values_schema=op_schemas\n            ),\n        )\n    else:\n        result = func(source_value=source_value)\n    outputs.set_value(target_type, result)\n", "config": {"python_class": {"python_class_name": "CreateTableModuleConfig", "python_module_name": "kiara_plugin.tabular.modules.table", "full_name": "kiara_plugin.tabular.modules.table.CreateTableModuleConfig"}, "config_values": {"constants": {"description": "Value constants for this module.", "type": "object", "value_default": {}, "required": false}, "defaults": {"description": "Value defaults for this module.", "type": "object", "value_default": {}, "required": false}, "source_type": {"description": "The value type of the source value.", "type": "string", "value_default": null, "required": true}, "target_type": {"description": "The value type of the target.", "type": "string", "value_default": null, "required": true}, "ignore_errors": {"description": "Whether to ignore convert errors and omit the failed items.", "type": "boolean", "value_default": false, "required": false}}}}}, "19": {"id": "module:zdpuAvtJAAff57xASJxvSmQ6w7SRS9W4wPQfUVftGcZAjtQdD", "desc": {"module_type": "import.file_bundle", "module_config": {"constants": {}, "defaults": {}}, "label": "import.file_bundle", "node_type": "operation", "level": 15}, "parentIds": ["value:1d1776f3-239f-4db7-b3dd-7d408bcd0302"], "info": {"type_name": "import.file_bundle", "documentation": {"description": "Import a folder (file_bundle) from the local filesystem.", "doc": null}, "authors": {"authors": [{"name": "Markus Binsteiner", "email": "markus@frkl.io"}]}, "context": {"references": {"source_repo": {"url": "https://github.com/DHARPA-Project/kiara", "desc": "The kiara project git repository."}, "documentation": {"url": "https://dharpa.org/kiara_documentation/", "desc": "The url for kiara documentation."}}, "tags": [], "labels": {"package": "kiara"}}, "python_class": {"python_class_name": "ImportFileBundleModule", "python_module_name": "kiara.modules.included_core_modules.filesystem", "full_name": "kiara.modules.included_core_modules.filesystem.ImportFileBundleModule"}, "process_src": "def process(self, inputs: ValueMap, outputs: ValueMap):\n\n    path = inputs.get_value_data(\"path\")\n\n    file_bundle = FileBundle.import_folder(source=path)\n    outputs.set_value(\"file_bundle\", file_bundle)\n", "config": {"python_class": {"python_class_name": "KiaraModuleConfig", "python_module_name": "kiara.models.module", "full_name": "kiara.models.module.KiaraModuleConfig"}, "config_values": {"constants": {"description": "Value constants for this module.", "type": "object", "value_default": {}, "required": false}, "defaults": {"description": "Value defaults for this module.", "type": "object", "value_default": {}, "required": false}}}}}, "20": {"id": "value:1d1776f3-239f-4db7-b3dd-7d408bcd0302", "desc": {"label": "path (string)", "node_type": "value", "data_type": "string", "data_type_config": {}, "level": 16}, "parentIds": [], "info": {"preview": "/Users/mariella.decrouychan/Documents/GitHub/DHARPA-Project-viz-observable/dag-lineage/example_data/mini_corpus"}}, "21": {"id": "value:9bf6c998-9d8b-4571-ac92-a7e3d8d87892", "desc": {"label": "max_index (integer)", "node_type": "value", "data_type": "integer", "data_type_config": {}, "level": 14}, "parentIds": [], "info": {"preview": "21"}}, "22": {"id": "value:ebfb1534-cef9-400c-9fdb-59c5d2f6302f", "desc": {"label": "min_index (integer)", "node_type": "value", "data_type": "integer", "data_type_config": {}, "level": 14}, "parentIds": [], "info": {"preview": "11"}}, "23": {"id": "value:5704a550-4f4c-44b2-95f3-bf25364a41ee", "desc": {"label": "words_per_topic (integer)", "node_type": "value", "data_type": "integer", "data_type_config": {}, "level": 4}, "parentIds": [], "info": {"preview": "10"}}}